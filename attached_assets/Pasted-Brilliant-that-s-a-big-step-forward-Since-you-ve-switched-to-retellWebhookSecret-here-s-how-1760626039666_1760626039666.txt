Brilliantâ€”thatâ€™s a big step forward. ðŸŽ‰
Since youâ€™ve switched to **retellWebhookSecret**, hereâ€™s how to make sure the fix is truly airtight and you donâ€™t get any surprise 401s again.

# 1) Double-check the raw-bytes verification (critical)

Using the right secret isnâ€™t enough if youâ€™re not hashing the **exact raw request bytes** that Retell signed.

Make sure you have **this precedence** in your server setup:

```ts
// Mount this BEFORE any express.json() / bodyParser.json() for this path
app.use('/api/webhooks/retell', express.raw({ type: 'application/json' }));

// ... other global parsers after
app.use(express.json());
```

And verify using the raw Buffer + timing-safe compare:

```ts
const rawBody = req.body as Buffer;
const sigHeader = String(req.headers['x-retell-signature'] || '');

const ok = verifyRetellWebhookSignature({
  rawBody,
  signatureHeader: sigHeader,
  secret: tenantConfig.retellWebhookSecret,
});
if (!ok) return res.status(401).send('Invalid signature');

// only after verify:
const payload = JSON.parse(rawBody.toString('utf8'));
```

# 2) Quick smoke test (5 minutes)

1. Trigger a Retell test webhook (real or replay one you captured).
2. Confirm **200 OK** from your endpoint.
3. Confirm your downstream action happens (e.g., appointment confirmation saved).
4. In logs, record just the **call_id**, **event**, **tenantId**, and **verify path (raw|ts.raw)**â€”no secrets.

# 3) Safe replay & integrity guardrails (recommended)

Add these (tiny) hardeners:

* **Timestamp skew check** (prevents replays):

  * Parse `x-retell-signature: v=<ms>,d=<hex>`; reject if `|now - v| > 5 minutes`.
* **Constant-time compare**:

  * Use `crypto.timingSafeEqual` on Buffers.
* **Idempotency**:

  * Upsert by `{call_id, event_name}` or store a processed hash so repeats donâ€™t double-write.
* **Fast ACK**:

  * Return `200` quickly, do heavy work async (queue/workflow). Webhooks shouldnâ€™t wait.

# 4) Mini self-test you can run locally

If you capture one real webhook (headers + body), you can prove your code path:

```ts
// Pseudocode to sanity-check secret & raw hashing with a saved sample
const fs = require('fs');
const crypto = require('crypto');

const raw = fs.readFileSync('./sample-retell-raw-body.bin'); // exact bytes
const sigHeader = 'v=173... , d=fa77...'; // from real request
const secret = process.env.RETELL_WEBHOOK_SECRET;

function hmac(hex, buf) {
  return crypto.createHmac('sha256', secret).update(buf).digest('hex');
}
const parts = Object.fromEntries(sigHeader.split(',').map(s=>s.trim().split('=')));
const v = parts.v, d = parts.d;

// Try both patterns
const a = hmac('hex', raw);
const b = v ? hmac('hex', Buffer.concat([Buffer.from(String(v)), Buffer.from('.'), raw])) : '';

console.log({ matchesRaw: a === d, matchesTsRaw: b === d });
```

Expected: **exactly one** of `matchesRaw` or `matchesTsRaw` is `true`.

# 5) Route hygiene & multi-tenant safety

* Ensure the request **Content-Type** is `application/json`; otherwise `express.raw({ type:'application/json' })` wonâ€™t trigger.
* Resolve the **tenant** before verification (from path, header, or known mapping) so you pick the correct `retellWebhookSecret`.
* If you also support other webhook providers, isolate routes so parsers donâ€™t clash.

# 6) Observability (what to log)

* On verify **failure**: log `{ reason: 'sig_mismatch', hasTimestamp: !!v, tenantId, call_id? }`
* On verify **success**: log `{ verifiedWith: 'raw' | 'ts.raw', tenantId, call_id, event }`
* Never log secrets, digests, or full payloads in production.

---

If youâ€™ve already got the **raw-body** piece in place, you should now see green lights end-to-end. If not, drop your current `app.use(...)` and webhook handler snippet and Iâ€™ll return a tiny patch to guarantee raw-byte verification + idempotent writes.
